<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>.b[Frequentist Inference, pt. I]</title>
    <meta charset="utf-8" />
    <meta name="author" content="Marcio Santetti" />
    <script src="lec16-freq-inference-1_files/header-attrs/header-attrs.js"></script>
    <link href="lec16-freq-inference-1_files/remark-css/default.css" rel="stylesheet" />
    <link href="lec16-freq-inference-1_files/remark-css/metropolis.css" rel="stylesheet" />
    <link href="lec16-freq-inference-1_files/remark-css/metropolis-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="utah-css.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# .b[Frequentist Inference, pt. I]
## .b[ECON 3640–001]
### Marcio Santetti
### Spring 2022

---

class: inverse, middle





# Motivation



---

# Housekeeping

&lt;br&gt;&lt;br&gt;


Notes based on `Keller (2009)`:

  - Chapter .b[10], sections `10.1` and `10.2`.
  

  


---

# Motivation

&lt;br&gt;&lt;br&gt;

When studying .b[*Bayesian*] inference, all our questions were answered through .hi[entire probability distributions].

--

In the case of .b[*frequentist*] inference, we appeal to the concept of .hi-blue[sampling distributions].

--

But how to .hi-green[link] sampling distributions to actual inference procedures?


---

layout: false
class: inverse, middle

# Point and Interval estimators

---


# Point and Interval estimators


The goal of statistical inference is to approximate a .hi-blue[population parameter] through a .hi[sample statistic].

--

For instance, the .b[estimator] of the population mean (*&amp;mu;*) is the sample mean, `\(\bar{x}\)`.

--

Once it is computed, the specific value of `\(\bar{x}\)` is an .b[estimate] of the population mean.

--

.hi[Careful!] An .b[estimator] is a formula/procedure one follows to obtain a measure of a parameter of interest. An .b[estimate] is a specific value calculated using an estimator.

--

A sample statistic may be used to represent a population parameter in two ways:

  1. Point estimator;
  2. Interval estimator.
  
---

# Point and Interval estimators

A .hi[point] estimator draws inferences about a population by estimating the value of an unknown parameter using a .hi-slate[single] value or point.

--

In the first part of the course, we spent some time using such estimators.

  - E.g., *sample mean, sample variance, sample standard deviation, sample median*....
  
--

These estimators, however, are .hi-green[fragile].

--

Recall that *P(X = x) = 0* for continuous random variables!

--

Furthermore, how does .red[*varying the sample size*] reflects how good/bad a point estimator is?

---

# Point and Interval estimators

.hi[Interval] estimators draw inferences about a population by estimating the value of an unknown parameter using an *interval.*

--

This way, representing a parameter of interest through an interval is .red[*better suited*] when we don't know the whole population.

--

And the sample size (*n*) .hi[does matter] here!

---

# Point and Interval estimators

&lt;br&gt;

The selection of the sample statistic to be used as an estimator, however, depends on the .hi[characteristics] of that statistic.

--

&lt;br&gt;

These are:

  1. Unbiasedness;
  2. Consistency;
  3. Efficiency.
  
---

# Point and Interval estimators

&lt;br&gt;

An .b[unbiased] estimator of a population parameter is an estimator whose *expected value is equal to that parameter*.

--

Unbiasedness implies that if one takes an .hi[infinite] number of samples and calculate the value of the estimator in each sample, the .red[*average value*] of the estimators would *equal* the parameter.

--

&lt;br&gt;




If there are two unbiased estimators of a parameter, the one whose variance is smaller is said to have .b[relative efficiency].

---

# Point and Interval estimators

.center[&lt;img src="p.png", width = "90%"&gt;]


---

# Point and Interval estimators

.b[Intuition] behind unbiasedness:

--

  - If one were to take an .hi-blue[infinite] amount of samples from the population and compute the value of the estimator (mean, median, variance, standard deviation...) in each sample, the .hi[average] value would equal the parameter.
  
  - `\(E(\bar{X}) = \mu\)`.
  
--

&lt;br&gt;

A third desirable propery of an estimator is .b[consistency].

--

It simply implies that, for an unbiased estimator, the difference between the estimator and the parameter grows smaller .red[*as the sample size grows larger*].

--

  - Therefore, consistency is a "large sample" property.
  
---

layout: false
class: inverse, middle

# Building interval estimators

---

# Building interval estimators

Now that we know where .hi[sampling distributions] come from and the desired .hi-blue[properties] of an estimator, we may move on to one inferential tool within frequentist inference:

--

  - .hi-green[Confidence intervals]


--

&lt;br&gt;

Assume the (unrealistic) scenario in which we are curious about a population's .hi[mean value] (*&amp;mu;*), and its .hi-blue[standard deviation] (*&amp;sigma;*) is known. 

--

So, the task is to draw a random sample *n* from the population *N* and obtain its sample mean, `\(\bar{x}\)`.

--

From the .hi-slate[Central Limit Theorem], if a random variable *X* is normally distributed, its mean `\(\bar{X}\)` will .hi[also] be normally distributed (or at least approximately).


---

# Building interval estimators

As we've already studied, the .hi[fundamental] parameters of the Normal distribution are the population .hi-blue[mean] and .hi-blue[standard deviation].

--

$$
`\begin{aligned}
X \sim \mathcal{N}(\mu, \sigma)
\end{aligned}`
$$

--

&lt;br&gt;

&lt;img src="lec16-freq-inference-1_files/figure-html/unnamed-chunk-1-1.svg" style="display: block; margin: auto;" /&gt;

---

# Building interval estimators

Given that the Normal distribution is .hi-slate[symmetric] about its .hi[mean], one very useful transformation we can apply to a normally distributed random variable is .b[standardization].

--

This simply implies transforming a variable such that it follows a .hi[Standard Normal] distribution.

--

  - The Standard Normal distribution implies a mean of 0 and a standard deviation (variance) of 1.
  
  - `\(X \sim \mathcal{N}(0, 1)\)`
  
--

&lt;br&gt;

To .hi-blue[standardize] a random variable, we apply the following formula:

$$
`\begin{aligned}
z = \dfrac{x - \mu}{\sigma}
\end{aligned}`
$$
---

# Building interval estimators

A quick example:

&lt;br&gt;

Suppose the daily demand for gasoline at a station is a normally distributed random variable with a mean of 1,000 and a standard deviation of 100 gallons.

The owner opened this station today and noted that there is exactly 1,100 gallons in storage. The next delivery will only happen tomorrow. She would like to know the probability that she will have enough regular gasoline to satisfy today’s demand.

---

# Building interval estimators

Visually:


&lt;img src="lec16-freq-inference-1_files/figure-html/unnamed-chunk-2-1.svg" style="display: block; margin: auto;" /&gt;

---

# Building interval estimators

And the area we are interested in is:

&lt;img src="lec16-freq-inference-1_files/figure-html/unnamed-chunk-3-1.svg" style="display: block; margin: auto;" /&gt;

---

# Building interval estimators

Let us standardize our random variable *X*:

$$
`\begin{aligned}
z = \dfrac{x - \mu}{\sigma} = \dfrac{1,100 - 1000}{100} = 1.00
\end{aligned}`
$$

&lt;br&gt;

--

Now, the random variable *z* follows a Standard Normal distribution!

--

And we are able to ask *P(z &lt; 1.00)*, instead of *P(X &lt; 1,100)*.

---

# Building interval estimators

Visually:

&lt;img src="lec16-freq-inference-1_files/figure-html/unnamed-chunk-4-1.svg" style="display: block; margin: auto;" /&gt;


---

# Building interval estimators

The values of *z* specify the .hi[location] of the corresponding value of *X*, our random variable.

--

A value of *z = 1.00* corresponds to a value of *X* that is .hi-blue[1.00 standard deviation above the mean].

--

Another *advantage* of standardizing a random variable to a *z* value is that it automatically centers the population mean (*&amp;mu;*) to .hi-blue[zero].

--

So what is this probability?


```r
pnorm(q = 1, mean = 0, sd = 1)
```

```
#&gt; [1] 0.8413447
```

--

Which is the same as


```r
pnorm(q = 1100, mean = 1000, sd = 100)
```

```
#&gt; [1] 0.8413447
```

---

# Building interval estimators

Now, we are ready to build a .hi[confidence interval] for a .hi-blue[population mean] of interest.

--

Applying the standardization process to a sample mean `\(\bar{X}\)`, we have

$$
`\begin{aligned}
Z = \dfrac{\bar{X} - \mu}{\sigma / \sqrt{n}}
\end{aligned}`
$$

--

&lt;br&gt;


And we want to get here:



$$
`\begin{aligned}
P(\bar{x} - z_{\dfrac{\alpha}{2}}\sigma/\sqrt{n} &lt; \mu &lt; \bar{x} + z_{\dfrac{\alpha}{2}}\sigma/\sqrt{n}) = 1 - \alpha
\end{aligned}`
$$
---

# Building interval estimators

Again:


$$
`\begin{aligned}
P(\bar{x} - z_{\dfrac{\alpha}{2}}\sigma/\sqrt{n} &lt; \mu &lt; \bar{x} + z_{\dfrac{\alpha}{2}}\sigma/\sqrt{n}) = 1 - \alpha
\end{aligned}`
$$



The **left-hand side** is a probability statement, which considers the probability with which the **population mean** `\((\mu)\)` lies between two values of the **sample mean**: one lower value, **corrected** downwards by  a **standard error** `\((z_{\alpha/2})\)`, multiplied by the **sampling distribution**'s standard deviation `\((\sigma/\sqrt{n})\)`; and one upper value, **corrected** upwards by the same factor. 

In other words, the above says that, with **repeated sampling** from this population, the proportion of values of `\(\bar{X}\)` for which the interval `\([\bar{x} - z_{\alpha/2}\sigma/\sqrt{n}; \bar{x} + z_{\alpha/2}\sigma/\sqrt{n}]\)` **includes** the population mean `\(\mu\)` is **equal to** `\(1-\alpha\)`.


---

# Building interval estimators

This form of probability statement is called the confidence interval estimator of `\(\mu\)`. 

--

The left part of the inequality on the left-hand side is known as the .hi[lower confidence limit] (LCL); while the right portion of the inequality is the .hi[upper confidence limit] (UCL). 

--

&lt;br&gt;

The right-hand side, `\(1-\alpha\)`, is the .hi-blue[confidence level] assumed for the confidence interval. 

--

  - The latter is usually pre-specified, and represents the probability that the interval includes the actual value of `\(\mu\)`.
  
---

# Building interval estimators

An example:

A computer store manager would like to estimate, with 95% of confidence, the optimum average inventory level. She also knows that the overall standard deviation is 75 computers. 

She has used a random sample of 25 periods, calculating a sample mean of 370.16 computers.

--

What is the .hi[area] we are interested in?

--

&lt;img src="lec16-freq-inference-1_files/figure-html/unnamed-chunk-7-1.svg" style="display: block; margin: auto;" /&gt;

---

layout: false
class: inverse, middle

# Next time: Hypothesis testing


---
exclude: true
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"ratio": "16:9",
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
